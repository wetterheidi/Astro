<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Astrotool</title>
    <style>
        body {
            font-family: Arial, Calibri, sans-serif;
            margin: 20px;
        }

        /* Tab-Styling */
        .tab {
            overflow: hidden;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }

        .tab button {
            background-color: #f1f1f1;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 16px;
        }

        .tab button:hover {
            background-color: #ddd;
        }

        .tab button.active {
            background-color: #ccc;
        }

        .tabcontent {
            display: none;
            padding: 20px 0;
        }

        .tabcontent.active {
            display: block;
        }

        /* Gemeinsames Tabellen-Styling */
        table {
            border-collapse: collapse;
            width: 100%;
            max-width: 800px;
            margin: 20px 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        th {
            background-color: #f2f2f2;
        }

        /* Schattenwurf-spezifisch */
        .shadow-table td {
            text-align: right;
        }

        .shadow-table th:nth-child(1),
        .shadow-table td:nth-child(1) {
            /* Zeit */
            width: 50px;
        }

        .shadow-table th:nth-child(2),
        .shadow-table td:nth-child(2) {
            /* Azimut */
            width: 60px;
        }

        .shadow-table th:nth-child(3),
        .shadow-table td:nth-child(3) {
            /* Elevation */
            width: 70px;
        }

        .shadow-table th:nth-child(4),
        .shadow-table td:nth-child(4) {
            /* Faktor */
            width: 60px;
        }

        .shadow-table th:nth-child(5),
        .shadow-table td:nth-child(5) {
            /* Schattenl√§nge */
            width: 100px;
        }

        .input-section {
            margin-bottom: 20px;
        }

        .error {
            color: red;
            margin-top: 10px;
        }

        /* Nachthelligkeiten-spezifisch */
        .night-table {
            table-layout: fixed;
            /* Erzwingt feste Breiten */
            width: 100%;
            /* Beibehalten, wie urspr√ºnglich */
            max-width: 800px;
            /* Beibehalten */
            margin: 20px 0;
            border-collapse: collapse;
        }

        .night-table td,
        .night-table th {
            text-align: center;
            width: 50px;
            /* Feste Breite f√ºr Stunden√ºberschriften und Werte */
            padding: 6px;
            /* Reduziert f√ºr mehr Textplatz */
            box-sizing: border-box;
            font-size: 14px;
            /* Kleinere Schrift f√ºr bessere Darstellung */
        }

        .night-table td:first-child,
        .night-table th:first-child {
            text-align: left;
            width: 60px;
            /* Breiter f√ºr Monatsnamen und Tage */
        }

        .night-table .big-value,
        .night-table .mid-value,
        .night-table .low-value,
        .night-table .tiny-value {
            width: 50px;
            /* Stelle sicher, dass Klassen die Breite nicht √ºberschreiben */
        }

        /* Sicherstellen, dass keine allgemeinen Regeln √ºberschreiben */
        table#tableWCalc.night-table td,
        table#tableWCalc.night-table th,
        table#tableBCalc.night-table td,
        table#tableBCalc.night-table th {
            width: 50px !important;
            /* Erzwingt Breite */
        }

        table#tableWCalc.night-table td:first-child,
        table#tableWCalc.night-table th:first-child,
        table#tableBCalc.night-table td:first-child,
        table#tableBCalc.night-table th:first-child {
            width: 60px !important;
            /* Erzwingt Breite f√ºr erste Spalte */
        }

        .big-value {
            background-color: #ffff99;
        }

        .mid-value {
            background-color: #ccffcc;
        }

        .low-value {
            background-color: #ffff99;
        }

        .tiny-value {
            background-color: #ffcccc;
        }

        .legend {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            display: inline-block;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: 30px 50px 120px 110px;
            gap: 10px;
            align-items: center;
        }

        .legend-grid .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #999;
        }

        .highlight-result {
            font-size: 24px;
            color: red;
            font-weight: bold;
        }

        /* Sonne & Mond Tabellen-Styling */
        .sun-moon-table {
            border-collapse: collapse;
            width: 100%;
            max-width: 600px;
            margin: 20px 0;
        }

        .sun-moon-table th,
        .sun-moon-table td {
            border: 1px solid darkgray;
            padding: 8px;
            text-align: center;
        }

        .sun-moon-table th {
            background-color: #f2f2f2;
        }

        /* Hintergrundfarben f√ºr Sonnen- und Mondzeilen */
        .sun-row {
            background-color: #ffffcc;
            /* Hellgelb */
        }

        .moon-row {
            background-color: #f0f0f0;
            /* Hellgrau */
        }

        .sun-moon-table th:nth-child(3),
        .sun-moon-table th:nth-child(4) .sun-moon-table td:nth-child(3),
        .sun-moon-table td:nth-child(4) {
            text-align: center;
            max-width: 50px;
            /* Zeit, Azimut und Elevation rechtsb√ºndig */
        }


        /* NEU: Spezifisches Styling f√ºr die Sonne & Mond Tabelle */
        .sun-moon-table th:nth-child(2),
        .sun-moon-table th:nth-child(1),
        .sun-moon-table td:nth-child(2),
        .sun-moon-table td:nth-child(1) {
            max-width: 90px;
            /* Feste Breite f√ºr die Zeitspalte */
            text-align: center;
            /* Zeit zentrieren */
        }

        /* Farben f√ºr kombinierte Tabelle */
        .combined-sun {
            background-color: #ffffcc;
            /* Hellgelb, wie im Sonne & Mond Tab */
        }

        .combined-moon {
            background-color: #f0f0f0;
            /* Hellgrau, wie im Sonne & Mond Tab */
        }

        .sun-header {
            background-color: #ffffcc;
            /* Hellgelb f√ºr Sonnen-Header */
        }

        .moon-header {
            background-color: #f0f0f0;
            /* Hellgrau f√ºr Mond-Header */
        }

        /* Monatstabelle Styling */
        .month-table {
            border-collapse: collapse;
            width: 100%;
            max-width: 1000px;
            /* Erh√∂ht f√ºr mehr Spalten */
            margin: 20px 0;
        }

        .month-table th,
        .month-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        .month-table th {
            background-color: #f2f2f2;
        }

        .month-table td:nth-child(n+2) {
            /* Alle Spalten au√üer "Tag" */
            text-align: right;
        }

        .month-table td:nth-child(1) {
            /* "Tag"-Spalte */
            text-align: left;
            width: 40px;
        }

        /* Tagesdaten Tabellen-Styling */
        .day-table {
            border-collapse: collapse;
            width: 100%;
            max-width: 600px;
            margin: 20px 0;
        }

        .day-table th,
        .day-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        .day-table th {
            background-color: #f2f2f2;
        }

        .day-table td:nth-child(1) {
            /* Zeit */
            text-align: left;
            width: 100px;
        }

        .day-table td:nth-child(2),
        .day-table td:nth-child(3) {
            /* Azimut, Elevation */
            text-align: right;
        }

        #polarChart {
            display: block;
            margin: 0 auto;
        }

        /* Intranetzugang erforderlich */
        .tablinks.intranet {
            background-color: #ffcccc;
            /* Hellrot */
        }

        .tablinks.intranet:hover {
            background-color: #ff9999;
            /* Dunkleres Rot beim Hover */
        }

        .tablinks.intranet.active {
            background-color: #ff6666;
            /* Noch dunkleres Rot, wenn aktiv */
        }

        /* Standalone f√§hig */
        .tablinks.standalone {
            background-color: #ccffcc;
            /* Hellgr√ºn */
        }

        .tablinks.standalone:hover {
            background-color: #99ff99;
            /* Dunkleres Gr√ºn beim Hover */
        }

        .tablinks.standalone.active {
            background-color: #66ff66;
            /* Noch dunkleres Gr√ºn, wenn aktiv */
        }

        /* Internet erforderlich */
        .tablinks.internet {
            background-color: #cce5ff;
            /* Hellblau */
        }

        .tablinks.internet:hover {
            background-color: #99ccff;
            /* Dunkleres Blau beim Hover */
        }

        .tablinks.internet.active {
            background-color: #66b3ff;
            /* Noch dunkleres Blau, wenn aktiv */
        }

        /* Styling f√ºr den Diagramm-Container */
        #chartContainer {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <h1>Astrotool</h1>

    <div class="tab">
        <button class="tablinks intranet" onclick="openTab(event, 'Night')" id="defaultOpen"
            title="Erfordert Intranetzugang">üîí Nachthelligkeiten</button>
        <button class="tablinks intranet" onclick="openTab(event, 'Shadow')" title="Erfordert Intranetzugang">üîí
            Schattenwurf</button>
        <button class="tablinks standalone" onclick="openTab(event, 'Maxar')" title="Standalone f√§hig">‚úî Maxar</button>
        <button class="tablinks internet" onclick="openTab(event, 'SunMoon')" title="Erfordert Internetzugang">üåê Sonne
            & Mond</button>
        <button class="tablinks internet" onclick="openTab(event, 'MonthTable')" title="Erfordert Internetzugang">üåê
            Monatstabelle</button>
        <button class="tablinks internet" onclick="openTab(event, 'DayData')" title="Erfordert Internetzugang">üåê
            Tagesdaten</button>
        <button class="tablinks internet" onclick="openTab(event, 'NightCalc')" title="Erfordert Internetzugang">üåê
            Nachthelligkeiten (Berechnet)</button>
    </div>

    <div id="Night" class="tabcontent">
        <label>Vorarbeit: Formular 4 f√ºr den gew√ºnschten Zeitraum als Textdatei (*.txt) abspeichern.</label>
        <br><br>
        <input type="file" id="nightFileInput" accept=".txt">
        <br>
        <div class="legend">
            <h3>Legende</h3>
            <div class="legend-grid">
                <span class="color-box" style="background-color: white;"></span>
                <span></span>
                <span>>= 1000 mlx</span>
                <span>day light</span>
                <span class="color-box" style="background-color: #ffff99;"></span>
                <span>B(right)</span>
                <span>10 - 1000 mlx</span>
                <span>NVG possible</span>
                <span class="color-box" style="background-color: #ccffcc;"></span>
                <span></span>
                <span>0,7 - 10 mlx</span>
                <span>NVG usable</span>
                <span class="color-box" style="background-color: #ffff99;"></span>
                <span>D(ark)</span>
                <span>0,1 - 0,7 mlx</span>
                <span>NVG restricted</span>
                <span class="color-box" style="background-color: #ffcccc;"></span>
                <span></span>
                <span>
                    <= 0,1 mlx</span>
                        <span>dark night</span>
            </div>
        </div>
        <h2>Tabelle wolkenlos</h2>
        <table id="tableW" class="night-table"></table>
        <h2>Tabelle bew√∂lkt</h2>
        <table id="tableB" class="night-table"></table>
    </div>

    <div id="Shadow" class="tabcontent">
        <label>Vorarbeit: Formular 3 (Mond) oder Formular 2 (Sonne) f√ºr den gew√ºnschten Zeitraum als Textdatei (*.txt)
            abspeichern.</label>
        <div class="input-section">
            <br>
            <label for="height">H√∂he des Gegenstands (in Metern): </label>
            <input type="number" id="height" step="0.1" min="0" value="1">
            <br><br>
            <input type="file" id="shadowFileInput" accept=".txt">
            <div id="error" class="error"></div>
        </div>
        <table id="resultTable" class="shadow-table">
            <thead>
                <tr>
                    <th>Zeit</th>
                    <th>Azimut (¬∞)</th>
                    <th>Elevation (¬∞)</th>
                    <th>Faktor</th>
                    <th>Schattenl√§nge (m)</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <div id="Maxar" class="tabcontent">
        <h2>Maxar</h2>
        <label>Vorarbeit: Metadatei als JSON-Datei (*.json) abspeichern (optional, wenn Sonnenelevation manuell
            eingegeben wird).</label>
        <div class="input-section">
            <br>
            <input type="file" id="maxarFileInput" accept=".json">
            <br><br>
            <div id="maxarInfo">
                <p>Sonnenazimut: <span id="sunAzimuth">N/A</span>¬∞</p>
                <label for="manualSunAzimuth">Sonnenazimut manuell eingeben (in Grad, √ºberschreibt JSON-Daten):</label>
                <input type="number" id="manualSunAzimuth" step="0.1" min="0" max="360" placeholder="Optional">
                <br><br>

                <p>Sonnenelevation: <span id="sunElevation">N/A</span>¬∞</p>
                <label for="manualSunElevation">Sonnenelevation manuell eingeben (in Grad, √ºberschreibt JSON-Daten):
                </label>
                <input type="number" id="manualSunElevation" step="0.1" min="0" max="90" placeholder="Optional">
                <br><br>
            </div>
            <label for="shadowLength">Schattenl√§nge (in Metern): </label>
            <input type="number" id="shadowLength" step="0.1" min="0" value="10">
            <br><br>
            <p class="highlight-result">Berechnete H√∂he des Gegenstands: <span id="objectHeight"
                    class="highlight-result">N/A</span> m</p>
            <div id="maxarError" class="error"></div>
        </div>
    </div>
    <div id="SunMoon" class="tabcontent">
        <h2>Sonne & Mond</h2>
        <div class="input-section">
            <label for="mgrsInputSunMoon">MGRS-Koordinate (z.B. 32U MV 12345 67890): </label>
            <input type="text" id="mgrsInputSunMoon" placeholder="MGRS eingeben" style="width: 250px;">
            <button onclick="convertMgrs('SunMoon')">Umwandeln</button>
            <span id="mgrsErrorSunMoon" class="error" style="margin-left: 10px;"></span>
            <br><br>
            <hr>
            <label for="latitude">Breitengrad (z.B. 47.975): </label>
            <input type="number" id="latitude" step="0.001" min="-90" max="90" value="47.975">
            <br><br>
            <label for="longitude">L√§ngengrad (z.B. 10.90): </label>
            <input type="number" id="longitude" step="0.001" min="-180" max="180" value="10.90">
            <br><br>
            <label for="date">Datum: </label>
            <input type="date" id="date" value="2025-04-07">
            <br><br>
            <label for="utcToggle">UTC-Zeit anzeigen: </label>
            <input type="checkbox" id="utcToggle" onchange="calculateSunMoon()">
            <br><br>
            <button onclick="calculateSunMoon()">Berechnen</button>
            <br><br>
            <label for="sortToggle">Zeitlich sortieren: </label>
            <input type="checkbox" id="sortToggle" onchange="sortTable()">
            <br><br>
            <div style="display: flex; align-items: flex-start; gap: 20px;">
                <div id="sunMoonResults" style="flex-grow: 1;">
                    <table id="sunMoonTable" class="sun-moon-table">
                        <thead>
                            <tr>
                                <th>Ereignis</th>
                                <th>Zeit</th>
                                <th>Azimut (¬∞)</th>
                                <th>Elevation (¬∞)</th>
                            </tr>
                        </thead>
                        <tbody id="sunMoonTableBody">
                            <tr class="sun-row">
                                <td>Ende dunkle Nacht (Morgen)</td>
                                <td id="nightEnd">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="sun-row">
                                <td>Beginn b√ºrgerliche D√§mmerung (Morgen)</td>
                                <td id="dawn">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="sun-row">
                                <td>Sonnenaufgang</td>
                                <td id="sunrise">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="sun-row">
                                <td>H√∂chststand Sonne</td>
                                <td id="solarNoon">N/A</td>
                                <td id="solarNoonAzimuth">N/A</td>
                                <td id="solarNoonElevation">N/A</td>
                            </tr>
                            <tr class="sun-row">
                                <td>Sonnenuntergang</td>
                                <td id="sunset">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="sun-row">
                                <td>Ende b√ºrgerliche D√§mmerung (Abend)</td>
                                <td id="dusk">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="sun-row">
                                <td>Beginn dunkle Nacht (Abend)</td>
                                <td id="night">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="moon-row">
                                <td>Mondaufgang</td>
                                <td id="moonrise">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="moon-row">
                                <td>H√∂chststand Mond</td>
                                <td id="moonNoon">N/A</td>
                                <td id="moonNoonAzimuth">N/A</td>
                                <td id="moonNoonElevation">N/A</td>
                            </tr>
                            <tr class="moon-row">
                                <td>Monduntergang</td>
                                <td id="moonset">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr class="moon-row">
                                <td>Mondphase</td>
                                <td id="moonPhase">N/A</td>
                                <td></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div id="moonClockContainer" style="position: relative; width: 600px; height: 340px;">
                    <img src="images/moon-phasesall--de.png" alt="Mondphasen-Uhr" style="width: 600px; height: 340px;">

                    <div id="moonPointer" style="
                        position: absolute;
                        bottom: 50%;
                        left: 50%;
                        width: 7px;
                        height: 80px;
                        background-color: #ff4d4d;
                        transform-origin: bottom center;
                        transform: rotate(0deg);
                        transition: transform 0.7s ease-in-out;
                        margin-left: -1px;
                        border-radius: 1px;
                        /* *** NEU: Positionierung f√ºr die Pfeilspitze *** */
                        display: flex; /* F√ºr die Ausrichtung des ::before Elements */
                        justify-content: center; /* Zentriert die Pfeilspitze oben */
                        align-items: flex-start; /* Platziert die Pfeilspitze am oberen Ende */
                    ">
                        <div style="
                            position: absolute;
                            top: -6px; /* Positioniert die Spitze etwas √ºber dem Zeiger */
                            width: 0;
                            height: 0;
                            border-left: 10px solid transparent;
                            border-right: 10px solid transparent;
                            border-bottom: 10px solid #ff4d4d; /* Farbe der Pfeilspitze */
                        "></div>
                    </div>
                    <div id="sunMoonError" class="error"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="MonthTable" class="tabcontent">
        <h2>Monatstabelle</h2>
        <div class="input-section">
            <label for="mgrsInputMonthTable">MGRS-Koordinate (z.B. 32U MV 12345 67890): </label>
            <input type="text" id="mgrsInputMonthTable" placeholder="MGRS eingeben" style="width: 250px;">
            <button onclick="convertMgrs('MonthTable')">Umwandeln</button>
            <span id="mgrsErrorMonthTable" class="error" style="margin-left: 10px;"></span>
            <br><br>
            <hr>
            <label for="monthLatitude">Breitengrad (z.B. 47.975): </label>
            <input type="number" id="monthLatitude" step="0.001" min="-90" max="90" value="47.975">
            <br><br>
            <label for="monthLongitude">L√§ngengrad (z.B. 10.90): </label>
            <input type="number" id="monthLongitude" step="0.001" min="-180" max="180" value="10.90">
            <br><br>
            <label for="monthYear">Monat und Jahr: </label>
            <input type="month" id="monthYear" value="2025-02">
            <br><br>
            <button onclick="calculateMonthTable()">Berechnen</button>
            <br><br>
            <label for="monthUtcToggle">UTC-Zeit anzeigen: </label>
            <input type="checkbox" id="monthUtcToggle" onchange="calculateMonthTable()">
            <br><br>
            <div id="monthTableResults">
                <table id="monthTable" class="month-table">
                    <thead>
                        <tr>
                            <th>Tag</th>
                            <th>Anfang astr. D√§mmerung</th>
                            <th>Ende dunkle Nacht</th>
                            <th>Anfang naut. D√§mmerung</th>
                            <th>Anfang b√ºrg. D√§mmerung</th>
                            <th>Sonnenaufgang</th>
                            <th>Sonnenuntergang</th>
                            <th>Ende b√ºrg. D√§mmerung</th>
                            <th>Ende naut. D√§mmerung</th>
                            <th>Anfang dunkle Nacht</th>
                            <th>Ende astr. D√§mmerung</th>
                            <th>Mondaufgang</th>
                            <th>Monduntergang</th>
                        </tr>
                    </thead>
                    <tbody id="monthTableBody"></tbody>
                </table>
            </div>
            <div id="monthTableError" class="error"></div>
        </div>
    </div>
    <div id="DayData" class="tabcontent">
        <h2>Tagesdaten</h2>
        <div class="input-section">
            <label for="mgrsInputDayData">MGRS-Koordinate (z.B. 32U MV 12345 67890): </label>
            <input type="text" id="mgrsInputDayData" placeholder="MGRS eingeben" style="width: 250px;">
            <button onclick="convertMgrs('DayData')">Umwandeln</button>
            <span id="mgrsErrorDayData" class="error" style="margin-left: 10px;"></span>
            <br><br>
            <hr>
            <label for="dayLatitude">Breitengrad (z.B. 47.975): </label>
            <input type="number" id="dayLatitude" step="0.001" min="-90" max="90" value="47.975">
            <br><br>
            <label for="dayLongitude">L√§ngengrad (z.B. 10.90): </label>
            <input type="number" id="dayLongitude" step="0.001" min="-180" max="180" value="10.90">
            <br><br>
            <label for="dayDate">Startdatum: </label>
            <input type="date" id="dayDate" value="2025-04-07">
            <br><br>
            <label for="startTime">Startuhrzeit (loc): </label>
            <input type="time" id="startTime" value="12:00">
            <br><br>
            <label for="objectHeightInput">H√∂he des Gegenstands (in Metern): </label>
            <input type="number" id="objectHeightInput" step="0.1" min="0" value="1">
            <br><br>
            <button onclick="calculateDayData()">Berechnen</button>
            <br><br>
            <label for="dayUtcToggle">UTC-Zeit anzeigen: </label>
            <input type="checkbox" id="dayUtcToggle" onchange="calculateDayData()">
            <br><br>
            <label for="showSun">Sonne anzeigen: </label>
            <input type="checkbox" id="showSun" checked onchange="calculateDayData()">
            <br><br>
            <label for="showMoon">Mond anzeigen: </label>
            <input type="checkbox" id="showMoon" checked onchange="calculateDayData()">
            <br><br>
            <div id="dayDataResults">
                <h3>Sonne und Mond</h3>
                <table id="combinedDayTable" class="day-table">
                    <thead>
                        <tr>
                            <th></th>
                            <th colspan="3" class="sun-header">Sonne</th>
                            <th colspan="3" class="moon-header">Mond</th>
                        </tr>
                        <tr>
                            <th>Uhrzeit</th>
                            <th class="sun-header">Azimut (¬∞)</th>
                            <th class="sun-header">Elevation (¬∞)</th>
                            <th class="sun-header">Schattenwurf (m)</th>
                            <th class="moon-header">Azimut (¬∞)</th>
                            <th class="moon-header">Elevation (¬∞)</th>
                            <th class="moon-header">Schattenwurf (m)</th>
                        </tr>
                    </thead>
                    <tbody id="combinedDayTableBody"></tbody>
                </table>
                <h3>Himmelsprojektion (Sonne und Mond)</h3>
                <canvas id="polarChart" width="600" height="600"></canvas>
                <div class="input-section">
                    <label for="transparentToggle">Transparenter Hintergrund (Polardiagrammlinien sind wei√ü!):
                    </label>
                    <input type="checkbox" id="transparentToggle" checked="true" onchange="calculateDayData()">
                    <br><br>
                    <button onclick="saveChart()">Diagramm als PNG speichern</button>
                </div>
            </div>
            <div id="dayDataError" class="error"></div>
        </div>
    </div>
    <div id="NightCalc" class="tabcontent">
        <h2>Nachthelligkeiten (Berechnet)</h2>
        <div class="input-section">
            <label for="mgrsInputNightCalc">MGRS-Koordinate (z.B. 32U MV 12345 67890): </label>
            <input type="text" id="mgrsInputNightCalc" placeholder="MGRS eingeben" style="width: 250px;">
            <button onclick="convertMgrs('NightCalc')">Umwandeln</button>
            <span id="mgrsErrorNightCalc" class="error" style="margin-left: 10px;"></span>
            <br><br>
            <hr>
            <label for="nightCalcLatitude">Breitengrad (z.B. 47.975): </label>
            <input type="number" id="nightCalcLatitude" step="0.001" min="-90" max="90" value="47.975">
            <br><br>
            <label for="nightCalcLongitude">L√§ngengrad (z.B. 10.90): </label>
            <input type="number" id="nightCalcLongitude" step="0.001" min="-180" max="180" value="10.90">
            <br><br>
            <label for="nightCalcMonthYear">Monat und Jahr: </label>
            <input type="month" id="nightCalcMonthYear" value="2025-04"><br><br>
            <label for="nightCalcUtcToggle">UTC-Zeit anzeigen: </label>
            <input type="checkbox" id="nightCalcUtcToggle" onchange="calculateMonthlyNightBrightness()"><br><br>
            <label for="displayMode">Anzeigemodus: </label>
            <select id="displayMode" onchange="calculateMonthlyNightBrightness()">
                <option value="numbers" selected>Zahlenwerte</option>
                <option value="conclusion">Conclusion</option>
            </select><br><br>
            <button onclick="calculateMonthlyNightBrightness()">Berechnen</button>
        </div>
        <div class="legend">
            <h3>Legende</h3>
            <div class="legend-grid">
                <span class="color-box" style="background-color: white;"></span><span></span><span>>= 1000
                    mlx</span><span>day light</span>
                <span class="color-box" style="background-color: #ffff99;"></span><span>B(right)</span><span>10 -
                    1000
                    mlx</span><span>NVG possible</span>
                <span class="color-box" style="background-color: #ccffcc;"></span><span></span><span>0,7 - 10
                    mlx</span><span>NVG usable</span>
                <span class="color-box" style="background-color: #ffff99;"></span><span>D(ark)</span><span>0,1 - 0,7
                    mlx</span><span>NVG restricted</span>
                <span class="color-box" style="background-color: #ffcccc;"></span><span></span><span>
                    <= 0,1 mlx</span><span>dark night</span>
            </div>
        </div>
        <h2>Tabelle wolkenlos</h2>
        <table id="tableWCalc" class="night-table"></table>
        <h2>Tabelle bew√∂lkt</h2>
        <table id="tableBCalc" class="night-table"></table>
        <div id="nightCalcResults"></div>
        <div id="nightCalcError" class="error"></div>

        <div id="chartContainer" style="display: none;">
            <h3>Diagramm der Nachthelligkeit</h3>
            <div class="input-section">
                <label for="daySelectorForChart">Tag f√ºr das Diagramm ausw√§hlen: </label>
                <select id="daySelectorForChart"></select>
            </div>
            <canvas id="nightBrightnessChart" width="800" height="400"></canvas>
        </div>
    </div>

</body>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
    // Tab-Funktionalit√§t
    function openTab(evt, tabName) {
        const tabcontent = document.getElementsByClassName("tabcontent");
        for (let i = 0; i < tabcontent.length; i++) {
            tabcontent[i].classList.remove("active");
        }
        const tablinks = document.getElementsByClassName("tablinks");
        for (let i = 0; i < tablinks.length; i++) {
            tablinks[i].classList.remove("active");
        }
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }

    // Standard-Tab √∂ffnen
    document.getElementById("defaultOpen").click();

    // Nachthelligkeiten Logik
    const nightFileInput = document.getElementById('nightFileInput');
    nightFileInput.addEventListener('change', processNightFile);

    function processNightFile() {
        const file = nightFileInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            const text = e.target.result;
            const rows = text.split('\n').map(row => row.split('\t').map(cell => cell.trim()));
            const headers = rows[0];
            headers[0] = headers[0].replace('wb', '');
            const dataRows = rows.slice(1);

            const wRows = dataRows.filter(row => row[0].endsWith('w'));
            const bRows = dataRows.filter(row => row[0].endsWith('b'));

            renderNightTable('tableW', headers, wRows);
            renderNightTable('tableB', headers, bRows);
        };
        reader.readAsText(file);
    }

    function renderNightTable(tableId, headers, rows) {
        const table = document.getElementById(tableId);
        table.innerHTML = '';

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        rows.forEach(row => {
            const tr = document.createElement('tr');
            row.forEach((cell, index) => {
                const td = document.createElement('td');
                const num = parseFloat(cell);

                if (index === 0) {
                    td.textContent = cell.slice(0, -1).trim();
                } else if (!isNaN(num)) {
                    if (num >= 10) {
                        td.textContent = 'B';
                        td.classList.add('big-value');
                    } else if (num > 0.7 && num < 10) {
                        td.textContent = '';
                        td.classList.add('mid-value');
                    } else if (num > 0.1 && num <= 0.7) {
                        td.textContent = 'D';
                        td.classList.add('low-value');
                    } else if (num <= 0.1) {
                        td.textContent = '';
                        td.classList.add('tiny-value');
                    }
                } else {
                    td.textContent = cell;
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
    }

    // Schattenwurf Logik
    const shadowFileInput = document.getElementById('shadowFileInput');
    const heightInput = document.getElementById('height');
    const tableBody = document.getElementById('tableBody');
    const errorDiv = document.getElementById('error');

    shadowFileInput.addEventListener('change', processShadowFile);
    heightInput.addEventListener('input', () => {
        if (shadowFileInput.files.length) {
            processShadowFile();
        }
    });

    function processShadowFile() {
        errorDiv.textContent = '';

        if (!shadowFileInput.files.length) {
            errorDiv.textContent = 'Bitte w√§hle eine Datei aus!';
            tableBody.innerHTML = '';
            return;
        }

        const height = parseFloat(heightInput.value);
        if (isNaN(height) || height <= 0) {
            errorDiv.textContent = 'Bitte gib eine g√ºltige H√∂he > 0 ein!';
            tableBody.innerHTML = '';
            return;
        }

        const file = shadowFileInput.files[0];
        const reader = new FileReader();

        reader.onload = function (e) {
            const text = e.target.result;
            const lines = text.split('\n');
            const dataArray = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const [time1, az1, el1, time2, az2, el2] = line.split('\t');
                processShadowData(time1, az1, el1, height, dataArray);
                if (time2) processShadowData(time2, az2, el2, height, dataArray);
            }

            dataArray.sort((a, b) => {
                const timeA = parseTime(a.time);
                const timeB = parseTime(b.time);
                return timeA - timeB;
            });

            tableBody.innerHTML = '';
            dataArray.forEach(data => {
                const row = document.createElement('tr');
                row.innerHTML = `
                        <td>${data.time}</td>
                        <td>${data.azimuth.toFixed(1)}</td>
                        <td>${data.elevation.toFixed(1)}</td>
                        <td>${data.factor.toFixed(1)}</td>
                        <td>${data.shadowLength.toFixed(1)}</td>
                    `;
                tableBody.appendChild(row);
            });
        };

        reader.onerror = function () {
            errorDiv.textContent = 'Fehler beim Lesen der Datei!';
            tableBody.innerHTML = '';
        };

        reader.readAsText(file);
    }

    function processShadowData(time, azimuth, elevation, height, dataArray) {
        elevation = parseFloat(elevation.replace(',', '.'));
        azimuth = parseFloat(azimuth.replace(',', '.'));

        if (elevation > 0) {
            const elevationRad = elevation * Math.PI / 180;
            const factor = 1 / Math.tan(elevationRad);
            const shadowLength = height * factor;

            dataArray.push({
                time,
                azimuth,
                elevation,
                factor,
                shadowLength
            });
        }
    }

    function parseTime(timeStr) {
        const [hours, minutes] = timeStr.split(':').map(Number);
        return hours * 60 + minutes;
    }

    // Maxar Logik
    const maxarFileInput = document.getElementById('maxarFileInput');
    const shadowLengthInput = document.getElementById('shadowLength');
    const manualSunElevationInput = document.getElementById('manualSunElevation');
    const manualSunAzimuthInput = document.getElementById('manualSunAzimuth'); // NEU
    const sunAzimuthSpan = document.getElementById('sunAzimuth');
    const sunElevationSpan = document.getElementById('sunElevation');
    const objectHeightSpan = document.getElementById('objectHeight');
    const maxarErrorDiv = document.getElementById('maxarError');

    // Globale Variablen, um die Werte aus der JSON-Datei zu speichern
    let jsonSunElevation = null;
    let jsonSunAzimuth = null;

    // Event Listeners
    maxarFileInput.addEventListener('change', processMaxarFile);
    shadowLengthInput.addEventListener('input', updateMaxarValuesAndCalculate);
    manualSunElevationInput.addEventListener('input', updateMaxarValuesAndCalculate);
    manualSunAzimuthInput.addEventListener('input', updateMaxarValuesAndCalculate); // NEU

    function processMaxarFile() {
        maxarErrorDiv.textContent = '';
        jsonSunElevation = null;
        jsonSunAzimuth = null;

        if (!maxarFileInput.files.length) {
            updateMaxarValuesAndCalculate();
            return;
        }

        const file = maxarFileInput.files[0];
        const reader = new FileReader();

        reader.onload = function (e) {
            try {
                const data = JSON.parse(e.target.result);
                jsonSunElevation = parseFloat(data.sun_elevation);
                jsonSunAzimuth = parseFloat(data.sun_azimuth);
            } catch (error) {
                maxarErrorDiv.textContent = 'Fehler beim Parsen der JSON-Datei!';
                console.error(error);
            } finally {
                updateMaxarValuesAndCalculate();
            }
        };

        reader.onerror = function () {
            maxarErrorDiv.textContent = 'Fehler beim Lesen der Datei!';
            updateMaxarValuesAndCalculate();
        };

        reader.readAsText(file);
    }

    // NEUE zentrale Funktion, die alle Werte aktualisiert und die Berechnung aufruft
    function updateMaxarValuesAndCalculate() {
        const manualAzimuth = parseFloat(manualSunAzimuthInput.value);
        const manualElevation = parseFloat(manualSunElevationInput.value);

        // Bestimme den effektiven Azimut (manuelle Eingabe hat Vorrang)
        const effectiveAzimuth = !isNaN(manualAzimuth) ? manualAzimuth : jsonSunAzimuth;
        // Bestimme die effektive Elevation (manuelle Eingabe hat Vorrang)
        const effectiveElevation = !isNaN(manualElevation) ? manualElevation : jsonSunElevation;

        // Aktualisiere die Anzeige
        sunAzimuthSpan.textContent = (effectiveAzimuth !== null && !isNaN(effectiveAzimuth)) ? effectiveAzimuth.toFixed(2) : 'N/A';
        sunElevationSpan.textContent = (effectiveElevation !== null && !isNaN(effectiveElevation)) ? effectiveElevation.toFixed(2) : 'N/A';

        // Rufe die eigentliche Berechnung auf
        calculateObjectHeight(effectiveElevation);
    }


    function calculateObjectHeight(effectiveElevation) {
        const shadowLength = parseFloat(shadowLengthInput.value);

        if (isNaN(shadowLength) || shadowLength < 0) {
            objectHeightSpan.textContent = 'N/A';
            maxarErrorDiv.textContent = 'Bitte gib eine g√ºltige Schattenl√§nge >= 0 ein!';
            return;
        }

        if (effectiveElevation === null || isNaN(effectiveElevation)) {
            objectHeightSpan.textContent = 'N/A';
            maxarErrorDiv.textContent = 'Bitte lade eine g√ºltige JSON-Datei oder gib die Sonnenelevation manuell ein!';
            return;
        }

        if (effectiveElevation <= 0 || effectiveElevation > 90) {
            objectHeightSpan.textContent = 'N/A';
            maxarErrorDiv.textContent = 'Sonnenelevation muss zwischen 0¬∞ und 90¬∞ liegen.';
            return;
        }

        maxarErrorDiv.textContent = '';

        const elevationRad = effectiveElevation * Math.PI / 180;
        const factor = Math.tan(elevationRad);
        const height = shadowLength * factor;

        objectHeightSpan.textContent = height.toFixed(2);
    }

    // Sonne & Mond Logik mit SunCalc
    const latitudeInput = document.getElementById('latitude');
    const longitudeInput = document.getElementById('longitude');
    const dateInput = document.getElementById('date');
    const dawnSpan = document.getElementById('dawn');
    const sunriseSpan = document.getElementById('sunrise');
    const solarNoonSpan = document.getElementById('solarNoon');
    const solarNoonAzimuthSpan = document.getElementById('solarNoonAzimuth');
    const solarNoonElevationSpan = document.getElementById('solarNoonElevation');
    const sunsetSpan = document.getElementById('sunset');
    const duskSpan = document.getElementById('dusk');
    const moonriseSpan = document.getElementById('moonrise');
    const moonNoonSpan = document.getElementById('moonNoon');
    const moonNoonAzimuthSpan = document.getElementById('moonNoonAzimuth');
    const moonNoonElevationSpan = document.getElementById('moonNoonElevation');
    const moonsetSpan = document.getElementById('moonset');
    const moonPhaseSpan = document.getElementById('moonPhase');
    const sunMoonErrorDiv = document.getElementById('sunMoonError');
    const sortToggle = document.getElementById('sortToggle');
    const utcToggle = document.getElementById('utcToggle');
    const sunMoonTableBody = document.getElementById('sunMoonTableBody');

    // Debugging: √úberpr√ºfe, ob alle Elemente gefunden wurden
    console.log('dawnSpan:', dawnSpan);
    console.log('sunriseSpan:', sunriseSpan);
    console.log('solarNoonSpan:', solarNoonSpan);
    console.log('solarNoonAzimuthSpan:', solarNoonAzimuthSpan);
    console.log('solarNoonElevationSpan:', solarNoonElevationSpan);
    console.log('sunsetSpan:', sunsetSpan);
    console.log('duskSpan:', duskSpan);
    console.log('moonriseSpan:', moonriseSpan);
    console.log('moonNoonSpan:', moonNoonSpan);
    console.log('moonNoonAzimuthSpan:', moonNoonAzimuthSpan);
    console.log('moonNoonElevationSpan:', moonNoonElevationSpan);
    console.log('moonsetSpan:', moonsetSpan);
    console.log('moonPhaseSpan:', moonPhaseSpan);
    console.log('sunMoonErrorDiv:', sunMoonErrorDiv);
    console.log('sortToggle:', sortToggle);
    console.log('utcToggle:', utcToggle);
    console.log('sunMoonTableBody:', sunMoonTableBody);

    let sunMoonData = [];

    function calculateSunMoon() {
        if (!sunMoonErrorDiv || !dawnSpan || !sunriseSpan || !solarNoonSpan || !solarNoonAzimuthSpan || !solarNoonElevationSpan || !sunsetSpan || !duskSpan || !moonriseSpan || !moonNoonSpan || !moonNoonAzimuthSpan || !moonNoonElevationSpan || !moonsetSpan || !moonPhaseSpan || !utcToggle) {
            console.error('Ein oder mehrere Elemente wurden nicht gefunden!');
            return;
        }

        sunMoonErrorDiv.textContent = '';
        const lat = parseFloat(latitudeInput.value);
        const lon = parseFloat(longitudeInput.value);
        const date = new Date(dateInput.value);

        if (isNaN(lat) || lat < -90 || lat > 90) { sunMoonErrorDiv.textContent = 'Bitte gib einen g√ºltigen Breitengrad zwischen -90 und 90 ein!'; return; }
        if (isNaN(lon) || lon < -180 || lon > 180) { sunMoonErrorDiv.textContent = 'Bitte gib einen g√ºltigen L√§ngengrad zwischen -180 und 180 ein!'; return; }
        if (isNaN(date.getTime())) { sunMoonErrorDiv.textContent = 'Bitte w√§hle ein g√ºltiges Datum!'; return; }

        const timeOptionsLocal = { hour: '2-digit', minute: '2-digit', hour12: false };
        const timeOptionsUTC = { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'UTC' };
        const timeOptions = utcToggle.checked ? timeOptionsUTC : timeOptionsLocal;

        const sunTimes = SunCalc.getTimes(date, lat, lon);
        const moonTimes = SunCalc.getMoonTimes(date, lat, lon);
        const moonIllumination = SunCalc.getMoonIllumination(date);
        const solarNoonPosition = SunCalc.getPosition(sunTimes.solarNoon, lat, lon);
        const moonNoon = findMoonNoon(date, lat, lon, utcToggle.checked);

        sunMoonData = [
            { event: 'Beginn b√ºrgerliche D√§mmerung (Morgen)', time: sunTimes.dawn, display: sunTimes.dawn.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: '', elevation: '', class: 'sun-row' },
            { event: 'Sonnenaufgang', time: sunTimes.sunrise, display: sunTimes.sunrise.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: '', elevation: '', class: 'sun-row' },
            { event: 'H√∂chststand Sonne', time: sunTimes.solarNoon, display: sunTimes.solarNoon.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: (((solarNoonPosition.azimuth * 180 / Math.PI) + 180) % 360).toFixed(1), elevation: (solarNoonPosition.altitude * 180 / Math.PI).toFixed(1), class: 'sun-row' },
            { event: 'Sonnenuntergang', time: sunTimes.sunset, display: sunTimes.sunset.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: '', elevation: '', class: 'sun-row' },
            { event: 'Ende b√ºrgerliche D√§mmerung (Abend)', time: sunTimes.dusk, display: sunTimes.dusk.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: '', elevation: '', class: 'sun-row' },
            { event: 'Mondaufgang', time: moonTimes.rise, display: moonTimes.rise ? moonTimes.rise.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions) : 'N/A', azimuth: '', elevation: '', class: 'moon-row' },
            { event: 'H√∂chststand Mond', time: moonNoon.time, display: moonNoon.time ? moonNoon.time.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions) : 'N/A', azimuth: moonNoon.azimuth ? moonNoon.azimuth.toFixed(1) : 'N/A', elevation: moonNoon.elevation ? moonNoon.elevation.toFixed(1) : 'N/A', class: 'moon-row' },
            { event: 'Monduntergang', time: moonTimes.set, display: moonTimes.set ? moonTimes.set.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions) : 'N/A', azimuth: '', elevation: '', class: 'moon-row' },
            { event: 'Mondphase', time: null, display: `${getMoonPhaseName(moonIllumination.phase)} (${(moonIllumination.fraction * 100).toFixed(1)}% beleuchtet)`, azimuth: '', elevation: '', class: 'moon-row' },
            { event: 'Ende dunkle Nacht', time: sunTimes.nightEnd, display: sunTimes.nightEnd.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: '', elevation: '', class: 'sun-row' },
            { event: 'Beginn dunkle Nacht', time: sunTimes.night, display: sunTimes.night.toLocaleTimeString(utcToggle.checked ? 'en-US' : 'de-DE', timeOptions), azimuth: '', elevation: '', class: 'sun-row' },
        ];

        renderTable();

        // *** NEUE LOGIK ZUR STEUERUNG DES MONDUHR-ZEIGERS ***
        const moonPointer = document.getElementById('moonPointer');
        const phase = moonIllumination.phase; // Ein Wert von 0.0 (Neumond) bis 1.0

        // Formel zur Umrechnung der Mondphase in einen Rotationswinkel (in Grad),
        // passend zur Anordnung der Phasen auf Ihrem Bild.
        // Bei Phase 0.75 (letztes Viertel, oben) ist der Winkel 0 Grad.
        const rotationAngle = (-phase * 360) + 270;

        // Wende die Rotation auf das 'transform'-Style-Attribut des Zeigers an
        moonPointer.style.transform = `rotate(${rotationAngle}deg)`;
    }

    // Funktion zum Finden des Mond-H√∂chststands
    function findMoonNoon(date, lat, lon, useUTC) {
        const startTime = new Date(date);
        startTime.setHours(0, 0, 0, 0); // Start um Mitternacht

        let maxElevation = -Infinity;
        let moonNoonTime = null;
        let moonNoonAzimuth = null;
        let moonNoonElevation = null;

        // Pr√ºfe die Mondposition st√ºndlich √ºber 24 Stunden
        for (let hour = 0; hour < 24; hour++) {
            const checkTime = new Date(startTime.getTime() + hour * 60 * 60 * 1000);
            const moonPosition = SunCalc.getMoonPosition(checkTime, lat, lon);
            const elevation = moonPosition.altitude * 180 / Math.PI; // In Grad umrechnen

            if (elevation > maxElevation) {
                maxElevation = elevation;
                moonNoonTime = checkTime;
                moonNoonAzimuth = (moonPosition.azimuth * 180 / Math.PI + 180) % 360; // Azimut in Grad umrechnen
                moonNoonElevation = elevation;
            }
        }

        return {
            time: moonNoonTime,
            azimuth: moonNoonAzimuth,
            elevation: moonNoonElevation
        };
    }

    function getMoonPhaseName(phaseValue) {
        if (phaseValue === 0) return 'Neumond';
        else if (phaseValue < 0.25) return 'Zunehmender Sichelmond';
        else if (phaseValue === 0.25) return 'Erstes Viertel';
        else if (phaseValue < 0.5) return 'Zunehmender Mond';
        else if (phaseValue === 0.5) return 'Vollmond';
        else if (phaseValue < 0.75) return 'Abnehmender Mond';
        else if (phaseValue === 0.75) return 'Letztes Viertel';
        else return 'Abnehmender Sichelmond';
    }

    function renderTable() {
        sunMoonTableBody.innerHTML = '';

        let dataToRender = [...sunMoonData];

        if (sortToggle.checked) {
            const moonriseIndex = dataToRender.findIndex(item => item.event === 'Mondaufgang');
            const moonPhaseIndex = dataToRender.findIndex(item => item.event === 'Mondphase');
            if (moonriseIndex !== -1 && moonPhaseIndex !== -1 && moonriseIndex < moonPhaseIndex) {
                const moonPhase = dataToRender.splice(moonPhaseIndex, 1)[0];
                dataToRender.splice(moonriseIndex + 1, 0, moonPhase);
            }

            dataToRender.sort((a, b) => {
                if (!a.time && !b.time) return 0;
                if (!a.time) return 1;
                if (!b.time) return -1;
                return a.time - b.time;
            });
        }

        dataToRender.forEach(item => {
            const row = document.createElement('tr');
            row.className = item.class;
            row.innerHTML = `
            <td>${item.event}</td>
            <td>${item.display}</td>
            <td>${item.azimuth}</td>
            <td>${item.elevation}</td>
        `;
            sunMoonTableBody.appendChild(row);
        });
    }

    function sortTable() {
        renderTable();
    }

    dateInput.addEventListener('change', calculateSunMoon);

    // Monatstabelle Logik mit SunCalc
    const monthLatitudeInput = document.getElementById('monthLatitude');
    const monthLongitudeInput = document.getElementById('monthLongitude');
    const monthYearInput = document.getElementById('monthYear');
    const monthUtcToggle = document.getElementById('monthUtcToggle');
    const monthTableBody = document.getElementById('monthTableBody');
    const monthTableErrorDiv = document.getElementById('monthTableError');

    function calculateMonthTable() {
        if (!monthTableErrorDiv || !monthTableBody) {
            console.error('Ein oder mehrere Elemente f√ºr die Monatstabelle wurden nicht gefunden!');
            return;
        }

        monthTableErrorDiv.textContent = '';
        monthTableBody.innerHTML = '';

        const lat = parseFloat(monthLatitudeInput.value);
        const lon = parseFloat(monthLongitudeInput.value);
        const monthYear = monthYearInput.value; // z.B. "2025-02"

        // Validierung
        if (isNaN(lat) || lat < -90 || lat > 90) {
            monthTableErrorDiv.textContent = 'Bitte gib einen g√ºltigen Breitengrad zwischen -90 und 90 ein!';
            return;
        }
        if (isNaN(lon) || lon < -180 || lon > 180) {
            monthTableErrorDiv.textContent = 'Bitte gib einen g√ºltigen L√§ngengrad zwischen -180 und 180 ein!';
            return;
        }
        if (!monthYear) {
            monthTableErrorDiv.textContent = 'Bitte w√§hle ein g√ºltiges Monat und Jahr!';
            return;
        }

        // Zeitformatierungsoptionen f√ºr hh:mm
        const timeOptionsLocal = { hour: '2-digit', minute: '2-digit', hour12: false };
        const timeOptionsUTC = { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'UTC' };
        const timeOptions = monthUtcToggle.checked ? timeOptionsUTC : timeOptionsLocal;

        const [year, month] = monthYear.split('-').map(Number); // z.B. [2025, 2]
        const daysInMonth = new Date(year, month, 0).getDate(); // Anzahl Tage im Monat

        for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, month - 1, day); // Monat -1, da JS 0-basiert ist

            // Sonnenzeiten
            const sunTimes = SunCalc.getTimes(date, lat, lon);

            // Mondzeiten
            const moonTimes = SunCalc.getMoonTimes(date, lat, lon);

            // Tabelle f√ºllen
            const row = document.createElement('tr');
            row.innerHTML = `
            <td>${day}</td>
            <td>${sunTimes.nightEnd.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}</td>
            <td>${sunTimes.nightEnd.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}</td>
            <td>${sunTimes.nauticalDawn.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}</td>
            <td>${sunTimes.dawn.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}</td>
            <td>${sunTimes.sunrise.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}</td>
            <td>${sunTimes.sunset.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}${isNextDay(sunTimes.sunset, date) ? '*' : ''}</td>
            <td>${sunTimes.dusk.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}${isNextDay(sunTimes.dusk, date) ? '*' : ''}</td>
            <td>${sunTimes.nauticalDusk.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}${isNextDay(sunTimes.nauticalDusk, date) ? '*' : ''}</td>
            <td>${sunTimes.night.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}${isNextDay(sunTimes.night, date) ? '*' : ''}</td>
            <td>${sunTimes.night.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}${isNextDay(sunTimes.night, date) ? '*' : ''}</td>
            <td>${moonTimes.rise ? moonTimes.rise.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions) : '**:**'}</td>
            <td>${moonTimes.set ? moonTimes.set.toLocaleTimeString(monthUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions) : '**:**'}</td>
        `;
            monthTableBody.appendChild(row);
        }
    }

    // Hilfsfunktion: Pr√ºft, ob ein Zeitpunkt am n√§chsten Tag liegt
    function isNextDay(time, baseDate) {
        const baseDay = baseDate.getDate();
        const timeDay = time.getDate();
        return timeDay !== baseDay;
    }

    // ==========================================================================================
    // START: MGRS-UMRECHNER BASIEREND AUF IHREM VB.NET CODE
    // ==========================================================================================

    // Haupt-Steuerungsfunktion, die von Ihrem HTML-Button aufgerufen wird.
    function convertMgrs(tabPrefix) {
        const mgrsInput = document.getElementById('mgrsInput' + tabPrefix);
        const errorSpan = document.getElementById('mgrsError' + tabPrefix);

        let latInput, lonInput;

        // Weist die korrekten Input-Felder je nach Tab zu
        if (tabPrefix === 'SunMoon') {
            latInput = document.getElementById('latitude');
            lonInput = document.getElementById('longitude');
        } else if (tabPrefix === 'MonthTable') {
            latInput = document.getElementById('monthLatitude');
            lonInput = document.getElementById('monthLongitude');
        } else if (tabPrefix === 'DayData') {
            latInput = document.getElementById('dayLatitude');
            lonInput = document.getElementById('dayLongitude');
        } else if (tabPrefix === 'NightCalc') {
            latInput = document.getElementById('nightCalcLatitude');
            lonInput = document.getElementById('nightCalcLongitude');
        }

        const mgrsValue = mgrsInput.value.trim();
        errorSpan.textContent = '';

        if (!mgrsValue) {
            errorSpan.textContent = 'Bitte MGRS-Koordinate eingeben.';
            return;
        }

        try {
            // Schritt 1: MGRS-String in UTM-Komponenten umwandeln
            const utm = vb_UTMREFinUTM(mgrsValue);

            // Schritt 2: UTM-Komponenten in Dezimalgrad umwandeln
            const coords = vb_UTMinDezimal(utm.box, utm.northing, utm.easting);

            // Felder aktualisieren
            latInput.value = coords.latitude.toFixed(5);
            lonInput.value = coords.longitude.toFixed(5);

            syncCoordinates(latInput);
            syncCoordinates(lonInput);

        } catch (e) {
            errorSpan.textContent = 'Ung√ºltige MGRS-Koordinate.';
            latInput.value = '';
            lonInput.value = '';
            console.error("MGRS Conversion Error:", e);
        }
    }


    // √úbersetzung Ihrer Funktion "UTMREFinUTM"
    function vb_UTMREFinUTM(UTMREF) {
        const utm = { box: "", easting: "", northing: "" };
        UTMREF = UTMREF.toUpperCase().replace(/\s+/g, ' '); // Stellt sicher, dass Leerzeichen konsistent sind
        const utmRefTeile = UTMREF.split(" ");

        if (utmRefTeile.length < 4) throw new Error("Invalid MGRS format. Expected 4 parts.");

        const ew2 = utmRefTeile[2];
        const nw2 = utmRefTeile[3];

        const m_east_0 = "STUVWXYZ";
        const m_east_1 = "ABCDEFGH";
        const m_east_2 = "JKLMNPQR";
        const m_north_0 = "FGHJKLMNPQRSTUVABCDE";
        const m_north_1 = "ABCDEFGHJKLMNPQRSTUV";

        const zoneNumberStr = utmRefTeile[0].substring(0, utmRefTeile[0].length - 1);
        const zoneNumber = parseInt(zoneNumberStr, 10);
        const band = utmRefTeile[0].slice(-1);
        const r_east = utmRefTeile[1].substring(0, 1);
        const r_north = utmRefTeile[1].substring(1, 2);

        let m_ce = "";
        const i_east = zoneNumber % 3;
        if (i_east === 0) {
            m_ce = (m_east_0.indexOf(r_east) + 1).toString();
        } else if (i_east === 1) {
            m_ce = (m_east_1.indexOf(r_east) + 1).toString();
        } else if (i_east === 2) {
            m_ce = (m_east_2.indexOf(r_east) + 1).toString();
        }

        const ew = m_ce + ew2;

        let m_cn_str = "";
        const i_north = zoneNumber % 2;
        if (i_north === 0) { // Gerade Zonennummer
            m_cn_str = m_north_0.indexOf(r_north).toString();
        } else { // Ungerade Zonennummer
            m_cn_str = m_north_1.indexOf(r_north).toString();
        }

        let m_cn = parseInt(m_cn_str, 10);

        // =========================================================================
        // FINAL KORRIGIERTER UND ERWEITERTER BLOCK
        // =========================================================================
        if (band >= "N") { // N√∂rdliche Hemisph√§re
            if (band === 'X') {
                // Band X (84N-90N) liegt vollst√§ndig im h√∂chsten Northing-Block (+8,000,000m)
                m_cn += 80;
            } else if (band === 'W' || band === 'V') {
                // Band W wird wie Band V behandelt, um den spezifischen Anwendungsfall zu l√∂sen.
                // Diese komplexe Regel wendet je nach Northing-Buchstabe unterschiedliche Offsets an.
                if (m_cn < 8) m_cn += 80; else if (m_cn < 28) m_cn += 60; else if (m_cn < 48) m_cn += 40; else if (m_cn < 68) m_cn += 20;
            } else if (band === "U") {
                if (m_cn < 48) m_cn += 60; else if (m_cn < 68) m_cn += 40;
            } else if (band === "T") {
                if (m_cn < 28) m_cn += 40; else if (m_cn < 48) m_cn += 20;
            } else if (band === "S") {
                if (m_cn < 8) m_cn += 40; else if (m_cn < 28) m_cn += 20;
            } else if (band === "R") {
                if (m_cn < 68) m_cn += 20;
            } else if (band === "Q") {
                if (m_cn < 48) m_cn += 20;
            } else if (band === "P") {
                if (m_cn < 28) m_cn += 20;
            }
        } else { // S√ºdliche Hemisph√§re
            if (band === "M") {
                if (m_cn < 88) m_cn += 100; else m_cn += 80;
            } else if (band === "L") {
                if (m_cn < 68) m_cn += 80; else m_cn += 60;
            } else if (band === "K") {
                if (m_cn < 48) m_cn += 80; else if (m_cn < 68) m_cn += 60;
            } else if (band === "J") {
                if (m_cn < 28) m_cn += 80; else if (m_cn < 48) m_cn += 60;
            } else if (band === "H") {
                if (m_cn < 8) m_cn += 80; else if (m_cn < 28) m_cn += 60; else m_cn += 40;
            } else if (band === "G") {
                if (m_cn < 68) m_cn += 60; else m_cn += 40;
            } else if (band === "F") {
                if (m_cn < 48) m_cn += 60; else if (m_cn < 68) m_cn += 40;
            } else if (band === "E") {
                if (m_cn < 28) m_cn += 60; else if (m_cn < 48) m_cn += 40;
            } else if (band === "D") {
                if (m_cn < 8) m_cn += 60; else if (m_cn < 28) m_cn += 40; else m_cn += 20;
            } else if (band === "C") {
                if (m_cn < 68) m_cn += 40; else m_cn += 20;
            }
        }
        // =========================================================================
        // ENDE DES BLOCKS
        // =========================================================================

        m_cn_str = m_cn.toString();
        let nw_prefix = m_cn_str.length === 1 ? "0" + m_cn_str : m_cn_str;
        if (nw_prefix.length > 2) nw_prefix = nw_prefix.substring(nw_prefix.length - 2);
        let nw = nw_prefix + nw2;

        utm.box = utmRefTeile[0];
        utm.northing = parseFloat(nw);
        utm.easting = parseFloat(ew);
        return utm;
    }

    // √úbersetzung Ihrer Funktion "UTMinDezimal"
    function vb_UTMinDezimal(box, northing, easting) {
        const boxNumber = parseInt(box.substring(0, 2), 10);
        const long0 = -177 + 6 * (boxNumber - 1);

        const k0 = 0.9996;
        const a = 6378137.0;    // WGS84 √Ñquatorradius
        const b = 6356752.3142; // WGS84 Polradius

        const eq2 = (1 - Math.pow(b, 2) / Math.pow(a, 2));
        const eq = Math.sqrt(eq2);
        const e1sq = eq2 / (1 - eq2);

        const arc = northing / k0;
        const mu = arc / (a * (1 - eq2 / 4.0 - 3 * Math.pow(eq2, 2) / 64.0 - 5 * Math.pow(eq2, 3) / 256.0));
        const ei = (1 - Math.sqrt(1 - eq2)) / (1 + Math.sqrt(1 - eq2));

        const ca = 3 * ei / 2 - 27 * Math.pow(ei, 3) / 32.0;
        const cb = 21 * Math.pow(ei, 2) / 16 - 55 * Math.pow(ei, 4) / 32;
        const cc = 151 * Math.pow(ei, 3) / 96;
        const cd = 1097 * Math.pow(ei, 4) / 512;

        const phi1 = mu + ca * Math.sin(2 * mu) + cb * Math.sin(4 * mu) + cc * Math.sin(6 * mu) + cd * Math.sin(8 * mu);
        const n0 = a / Math.sqrt(1 - Math.pow(eq * Math.sin(phi1), 2));
        const r0 = a * (1 - eq2) / Math.pow(1 - Math.pow(eq * Math.sin(phi1), 2), 1.5);
        const fact1 = n0 * Math.tan(phi1) / r0;

        const a1 = 500000 - easting;
        const dd0 = a1 / (n0 * k0);
        const fact2 = dd0 * dd0 / 2;

        const t0 = Math.pow(Math.tan(phi1), 2);
        const Q0 = e1sq * Math.pow(Math.cos(phi1), 2);
        const fact3 = (5 + 3 * t0 + 10 * Q0 - 4 * Q0 * Q0 - 9 * e1sq) * Math.pow(dd0, 4) / 24;
        const fact4 = (61 + 90 * t0 + 298 * Q0 + 45 * t0 * t0 - 252 * e1sq - 3 * Q0 * Q0) * Math.pow(dd0, 6) / 720;

        const latitude = 180 * (phi1 - fact1 * (fact2 + fact3 + fact4)) / Math.PI;

        const lof1 = dd0; // Vereinfacht, war a1 / (n0 * k0)
        const lof2 = (1 + 2 * t0 + Q0) * Math.pow(dd0, 3) / 6.0;
        const lof3 = (5 - 2 * Q0 + 28 * t0 - 3 * Math.pow(Q0, 2) + 8 * e1sq + 24 * Math.pow(t0, 2)) * Math.pow(dd0, 5) / 120;
        const a2 = (lof1 - lof2 + lof3) / Math.cos(phi1);
        const a3 = a2 * 180 / Math.PI;
        const longitude = long0 - a3;

        return { latitude: latitude, longitude: longitude };
    }

    // ==========================================================================================
    // ENDE: MGRS-UMRECHNER
    // ==========================================================================================

    // Event-Listener f√ºr Eingaben
    monthYearInput.addEventListener('change', calculateMonthTable);

    // Tagesdaten Logik mit SunCalc
    const dayLatitudeInput = document.getElementById('dayLatitude');
    const dayLongitudeInput = document.getElementById('dayLongitude');
    const dayDateInput = document.getElementById('dayDate');
    const startTimeInput = document.getElementById('startTime');
    const objectHeightInput = document.getElementById('objectHeightInput');
    const dayUtcToggle = document.getElementById('dayUtcToggle');
    const sunDayTableBody = document.getElementById('sunDayTableBody');
    const moonDayTableBody = document.getElementById('moonDayTableBody');
    const dayDataErrorDiv = document.getElementById('dayDataError');
    const polarChartCanvas = document.getElementById('polarChart');

    function calculateDayData() {
        if (!dayDataErrorDiv || !objectHeightInput || !polarChartCanvas || !startTimeInput) {
            console.error('Ein oder mehrere Elemente f√ºr die Tagesdaten wurden nicht gefunden!');
            return;
        }

        dayDataErrorDiv.textContent = '';
        const combinedDayTableBody = document.getElementById('combinedDayTableBody');
        combinedDayTableBody.innerHTML = '';

        const lat = parseFloat(dayLatitudeInput.value);
        const lon = parseFloat(dayLongitudeInput.value);
        const date = new Date(dayDateInput.value);
        const startTime = startTimeInput.value;
        const height = parseFloat(objectHeightInput.value);

        if (isNaN(lat) || lat < -90 || lat > 90) { dayDataErrorDiv.textContent = 'Bitte gib einen g√ºltigen Breitengrad ein!'; return; }
        if (isNaN(lon) || lon < -180 || lon > 180) { dayDataErrorDiv.textContent = 'Bitte gib einen g√ºltigen L√§ngengrad ein!'; return; }
        if (isNaN(date.getTime())) { dayDataErrorDiv.textContent = 'Bitte w√§hle ein g√ºltiges Datum!'; return; }
        if (!startTime) { dayDataErrorDiv.textContent = 'Bitte gib eine g√ºltige Startuhrzeit ein!'; return; }
        if (isNaN(height) || height <= 0) { dayDataErrorDiv.textContent = 'Bitte gib eine g√ºltige H√∂he > 0 ein!'; return; }

        const [hours, minutes] = startTime.split(':').map(Number);
        const startDateTime = new Date(date);
        startDateTime.setHours(hours, minutes, 0, 0);

        const timeOptionsLocal = { hour: '2-digit', minute: '2-digit', hour12: false };
        const timeOptionsUTC = { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'UTC' };
        const timeOptions = dayUtcToggle.checked ? timeOptionsUTC : timeOptionsLocal;

        const sunPositions = [];
        const moonPositions = [];
        const labels = [];
        const endDateTime = new Date(startDateTime.getTime() + 24 * 60 * 60 * 1000);

        // 1. Halbst√ºndliche Daten f√ºr die Pfade sammeln
        for (let halfHour = 0; halfHour < 48; halfHour++) {
            const checkTime = new Date(startDateTime.getTime() + halfHour * 30 * 60 * 1000);
            const sunPosition = SunCalc.getPosition(checkTime, lat, lon);
            sunPositions.push({
                time: checkTime,
                azimuth: (((sunPosition.azimuth * 180 / Math.PI) + 180) % 360),
                elevation: (sunPosition.altitude * 180 / Math.PI),
                isEvent: false // Markierung, dass dies ein regul√§rer Pfadpunkt ist
            });

            const moonPosition = SunCalc.getMoonPosition(checkTime, lat, lon);
            moonPositions.push({
                time: checkTime,
                azimuth: (((moonPosition.azimuth * 180 / Math.PI) + 180) % 360),
                elevation: (moonPosition.altitude * 180 / Math.PI),
                isEvent: false
            });

            const sunElevationForTable = (sunPosition.altitude * 180 / Math.PI);
            const moonElevationForTable = (moonPosition.altitude * 180 / Math.PI);
            const sunShadowLength = sunElevationForTable > 0 ? (height / Math.tan(sunPosition.altitude)).toFixed(1) : 'N/A';
            const moonShadowLength = moonElevationForTable > 0 ? (height / Math.tan(moonPosition.altitude)).toFixed(1) : 'N/A';
            const row = document.createElement('tr');
            row.innerHTML = `<td>${checkTime.toLocaleTimeString(dayUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions)}</td><td class="combined-sun">${sunPositions[sunPositions.length - 1].azimuth.toFixed(1)}</td><td class="combined-sun">${sunElevationForTable.toFixed(1)}</td><td class="combined-sun">${sunShadowLength}</td><td class="combined-moon">${moonPositions[moonPositions.length - 1].azimuth.toFixed(1)}</td><td class="combined-moon">${moonElevationForTable.toFixed(1)}</td><td class="combined-moon">${moonShadowLength}</td>`;
            combinedDayTableBody.appendChild(row);
        }

        // 2. Exakte Ereignispunkte sammeln und zur selben Liste hinzuf√ºgen
        const sunTimesStartDay = SunCalc.getTimes(startDateTime, lat, lon);
        const sunTimesEndDay = SunCalc.getTimes(endDateTime, lat, lon);
        const moonTimesStartDay = SunCalc.getMoonTimes(startDateTime, lat, lon);
        const moonTimesEndDay = SunCalc.getMoonTimes(endDateTime, lat, lon);

        const potentialSunEvents = [
            { name: 'SA', time: sunTimesStartDay.sunrise, color: 'orange' },
            { name: 'SU', time: sunTimesStartDay.sunset, color: 'orange' },
            { name: 'SA', time: sunTimesEndDay.sunrise, color: 'orange' },
            { name: 'SU', time: sunTimesEndDay.sunset, color: 'orange' }
        ];
        const potentialMoonEvents = [
            { name: 'MA', time: moonTimesStartDay.rise, color: 'yellow' },
            { name: 'MU', time: moonTimesStartDay.set, color: 'yellow' },
            { name: 'MA', time: moonTimesEndDay.rise, color: 'yellow' },
            { name: 'MU', time: moonTimesEndDay.set, color: 'yellow' }
        ];

        potentialSunEvents.forEach(event => {
            if (event.time && event.time >= startDateTime && event.time <= endDateTime) {
                const position = SunCalc.getPosition(event.time, lat, lon);
                sunPositions.push({
                    time: event.time,
                    azimuth: (((position.azimuth * 180 / Math.PI) + 180) % 360),
                    elevation: Math.max(0, position.altitude * 180 / Math.PI),
                    isEvent: true, // Markierung als spezieller Ereignispunkt
                    eventName: event.name,
                    eventColor: event.color
                });
            }
        });

        potentialMoonEvents.forEach(event => {
            if (event.time && event.time >= startDateTime && event.time <= endDateTime) {
                const position = SunCalc.getMoonPosition(event.time, lat, lon);
                moonPositions.push({
                    time: event.time,
                    azimuth: (((position.azimuth * 180 / Math.PI) + 180) % 360),
                    elevation: Math.max(0, position.altitude * 180 / Math.PI),
                    isEvent: true,
                    eventName: event.name,
                    eventColor: event.color
                });
            }
        });

        // 3. Die kombinierte Liste sortieren
        sunPositions.sort((a, b) => a.time - b.time);
        moonPositions.sort((a, b) => a.time - b.time);

        // 4. Diagramm rendern
        renderPolarChart(sunPositions, moonPositions, labels, timeOptions);
    }

    // Funktion zum Rendern des Polardiagramms
    function renderPolarChart(sunPositions, moonPositions, labels, timeOptions) {
        const ctx = polarChartCanvas.getContext('2d');
        ctx.clearRect(0, 0, polarChartCanvas.width, polarChartCanvas.height);

        const width = polarChartCanvas.width;
        const height = polarChartCanvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) / 2 - 110;
        const isTransparent = document.getElementById('transparentToggle').checked;

        const showSun = document.getElementById('showSun').checked;
        const showMoon = document.getElementById('showMoon').checked;

        let gridLineColor, gridLineWidth, gridDegreeColor, gridDirectionColor;
        if (isTransparent) {
            gridLineColor = 'white'; gridLineWidth = 2; gridDegreeColor = 'white'; gridDirectionColor = 'white';
        } else {
            gridLineColor = '#ccc'; gridLineWidth = 1; gridDegreeColor = '#666'; gridDirectionColor = '#000';
        }

        ctx.strokeStyle = gridLineColor;
        ctx.lineWidth = gridLineWidth;
        for (let elevation = 0; elevation <= 90; elevation += 30) {
            const radius = (1 - elevation / 90) * maxRadius;
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.stroke();
            ctx.fillStyle = gridDegreeColor; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`${elevation}¬∞`, centerX, centerY - radius - 10);
        }
        for (let azimuth = 0; azimuth < 360; azimuth += 45) {
            const angleRad = (azimuth * Math.PI) / 180;
            const x = centerX + maxRadius * Math.sin(angleRad); const y = centerY - maxRadius * Math.cos(angleRad);
            ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(x, y); ctx.stroke();
        }
        ctx.fillStyle = gridDirectionColor; ctx.font = '14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const directions = [{ label: 'N', angle: 0 }, { label: 'NE', angle: 45 }, { label: 'E', angle: 90 }, { label: 'SE', angle: 135 }, { label: 'S', angle: 180 }, { label: 'SW', angle: 225 }, { label: 'W', angle: 270 }, { label: 'NW', angle: 315 }];
        directions.forEach(dir => {
            const angleRad = (dir.angle * Math.PI) / 180;
            const x = centerX + (maxRadius + 20) * Math.sin(angleRad); const y = centerY - (maxRadius + 20) * Math.cos(angleRad);
            ctx.fillText(dir.label, x, y);
        });

        // *** KOMPLETT NEU GESCHRIEBENE, KORREKTE HILFSFUNKTION ZUM ZEICHNEN DER PFADE ***
        const drawPath = (positions, color) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            let firstPointOfSegment = true;

            positions.forEach(pos => {
                const angleRad = (pos.azimuth * Math.PI) / 180;
                const radius = (1 - pos.elevation / 90) * maxRadius;
                const x = centerX + radius * Math.sin(angleRad);
                const y = centerY - radius * Math.cos(angleRad);

                // Nur zeichnen, wenn der Punkt sichtbar ist
                if (pos.elevation >= 0) {
                    if (firstPointOfSegment) {
                        ctx.moveTo(x, y); // Beginne einen neuen Linienabschnitt
                        firstPointOfSegment = false;
                    } else {
                        ctx.lineTo(x, y); // Setze den aktuellen Linienabschnitt fort
                    }
                } else {
                    // Wenn ein unsichtbarer Punkt erreicht wird, wird der n√§chste sichtbare Punkt einen neuen Abschnitt beginnen
                    firstPointOfSegment = true;
                }
            });
            ctx.stroke();
        };

        if (showSun) drawPath(sunPositions, 'orange');
        if (showMoon) drawPath(moonPositions, 'yellow');

        const labelPositions = [];
        const drawEventMarkers = (positions) => {
            positions.forEach(pos => {
                if (!pos.isEvent) return;
                const angleRad = (pos.azimuth * Math.PI) / 180;
                const radius = (1 - pos.elevation / 90) * maxRadius;
                const x = centerX + radius * Math.sin(angleRad);
                const y = centerY - radius * Math.cos(angleRad);
                ctx.fillStyle = pos.eventColor; ctx.beginPath(); ctx.arc(x, y, 7, 0, 2 * Math.PI); ctx.fill();
                const timeStr = pos.time.toLocaleTimeString(dayUtcToggle.checked ? 'en-US' : 'de-DE', timeOptions);
                const day = pos.time.getDate().toString().padStart(2, '0'); const month = (pos.time.getMonth() + 1).toString().padStart(2, '0');
                const dateStr = `${day}.${month}.`; const dateTimeStr = `${dateStr} ${timeStr}`;
                let labelX = centerX + (maxRadius + 70) * Math.sin(angleRad);
                let labelY = centerY - (maxRadius + 70) * Math.cos(angleRad);
                let offsetY = 0; let offsetX = 0;
                labelPositions.forEach(p => {
                    if (Math.abs(pos.azimuth - p.azimuth) < 15) {
                        if (Math.abs(labelY - p.labelY) < 40) { if (labelY < centerY) offsetY -= 40; else offsetY += 40; }
                        if (Math.abs(labelX - p.labelX) < 10) { if (labelX < centerX) offsetX -= 10; else offsetX += 10; }
                    }
                });
                labelX += offsetX; labelY += offsetY;
                if (isTransparent) {
                    ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center';
                    const rectWidth = 110; const rectHeight = 40;
                    ctx.fillStyle = 'white'; ctx.fillRect(labelX - rectWidth / 2, labelY - rectHeight / 2, rectWidth, rectHeight);
                }
                ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(pos.eventName, labelX, labelY - 8);
                ctx.fillText(dateTimeStr, labelX, labelY + 10);
                labelPositions.push({ azimuth: pos.azimuth, labelX, labelY });
            });
        };

        if (showSun) drawEventMarkers(sunPositions);
        if (showMoon) drawEventMarkers(moonPositions);

        // Der fehlerhafte "L√ºckenf√ºller" wurde entfernt. Er wird nicht mehr ben√∂tigt.

        ctx.font = '12px Arial'; ctx.textAlign = 'left';
        let legendY = centerY + maxRadius + 50;
        if (showSun) {
            ctx.fillStyle = 'orange'; ctx.fillRect(centerX - 50, legendY - 5, 20, 10);
            ctx.fillStyle = '#000'; ctx.fillText('Sonne', centerX - 25, legendY);
            legendY += 20;
        }
        if (showMoon) {
            ctx.fillStyle = 'yellow'; ctx.fillRect(centerX - 50, legendY - 5, 20, 10);
            ctx.fillStyle = '#000'; ctx.fillText('Mond', centerX - 25, legendY);
        }
    }

    // NEU: Funktion zum Speichern des Diagramms als PNG
    function saveChart() {
        // 1. Sicherstellen, dass das Diagramm mit den aktuellen Einstellungen (inkl. Transparenz) gezeichnet ist
        calculateDayData();

        // 2. Die Daten des Canvas als PNG-Daten-URL abrufen
        const dataUrl = polarChartCanvas.toDataURL('image/png');

        // 3. Einen tempor√§ren Link erstellen, um den Download auszul√∂sen
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'Himmelsprojektion.png'; // Dateiname f√ºr den Download

        // 4. Den Link zum DOM hinzuf√ºgen, klicken und wieder entfernen
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Event-Listener f√ºr Eingaben
    dayDateInput.addEventListener('change', calculateDayData);
    startTimeInput.addEventListener('change', calculateDayData);
    objectHeightInput.addEventListener('change', calculateDayData);

    // Funktion zum Setzen des aktuellen Datums
    function setCurrentDate() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');

        const dateString = `${year}-${month}-${day}`;
        const monthString = `${year}-${month}`;

        document.getElementById('date').value = dateString;
        document.getElementById('monthYear').value = monthString;
        document.getElementById('dayDate').value = dateString;
        // Hinzugef√ºgt f√ºr den neuen Tab
        if (document.getElementById('nightCalcMonthYear')) {
            document.getElementById('nightCalcMonthYear').value = monthString;
        }
    }

    // Funktion zur Synchronisierung der Koordinaten
    function syncCoordinates(sourceField) {
        const latitudeInputs = [
            document.getElementById('latitude'),      // Sonne & Mond
            document.getElementById('monthLatitude'), // Monatstabelle
            document.getElementById('dayLatitude'),   // Tagesdaten
            document.getElementById('nightCalcLatitude') // Nachthelligkeiten berechnet
        ];
        const longitudeInputs = [
            document.getElementById('longitude'),      // Sonne & Mond
            document.getElementById('monthLongitude'), // Monatstabelle
            document.getElementById('dayLongitude'),    // Tagesdaten
            document.getElementById('nightCalcLongitude') // Nachthelligkeiten berechnet
        ];

        const isLatitude = sourceField.id.includes('Latitude') || sourceField.id === 'latitude';
        const isLongitude = sourceField.id.includes('Longitude') || sourceField.id === 'longitude';
        const value = sourceField.value;

        if (isLatitude) {
            latitudeInputs.forEach(input => {
                if (input !== sourceField) {
                    input.value = value;
                }
            });
        } else if (isLongitude) {
            longitudeInputs.forEach(input => {
                if (input !== sourceField) {
                    input.value = value;
                }
            });
        }

        if (sunMoonTableBody.innerHTML !== '') calculateSunMoon();
        if (monthTableBody.innerHTML !== '') calculateMonthTable();
        if (document.getElementById('combinedDayTableBody').innerHTML !== '') calculateDayData();
        if (document.getElementById('tableWCalc').innerHTML !== '') calculateMonthlyNightBrightness();
    }

    // Synchronisiere Koordinaten bei √Ñnderung
    latitudeInput.addEventListener('change', function () { syncCoordinates(this); });
    longitudeInput.addEventListener('change', function () { syncCoordinates(this); });
    monthLatitudeInput.addEventListener('change', function () { syncCoordinates(this); });
    monthLongitudeInput.addEventListener('change', function () { syncCoordinates(this); });
    dayLatitudeInput.addEventListener('change', function () { syncCoordinates(this); });
    dayLongitudeInput.addEventListener('change', function () { syncCoordinates(this); });


    // Hinzugef√ºgte Logik f√ºr "Nachthelligkeiten (Berechnet)"

    // Globale Variablen f√ºr Chart-Daten und Instanz
    let nightChart;
    let chartHeaders = [];
    let chartValuesW = [];
    let chartValuesB = [];

    //Finale Funktion f√ºr die Helligkeiten
    function calculateSkyBrightness(time, lat, lon, moonIllum, moonPos, sunPos) {
        const moonFraction = moonIllum.fraction;
        const moonElevation = moonPos.altitude * 180 / Math.PI;
        const sunElevation = sunPos.altitude * 180 / Math.PI;
        const phaseAngle = Math.acos(2 * moonFraction - 1) * 180 / Math.PI;
        const zenithDistance = 90 - moonElevation;
        const airmass = zenithDistance <= 80 ? 1 / Math.cos(zenithDistance * Math.PI / 180) : 40;
        const k = 0.3;

        let skyBrightnessMag = 22.0;
        let moonBrightness = 0;
        if (moonElevation > 0) {
            const mMoon = -12.73 + 0.026 * Math.abs(phaseAngle) + 4e-9 * Math.pow(phaseAngle, 4);
            const rho = 90 - moonElevation;
            const k_flux = 1e-6;
            const C_rho = k_flux * (1 + Math.cos(rho * Math.PI / 180)) * moonFraction;
            const flux_nL = C_rho;
            const flux_cd_m2 = flux_nL * 1e-9 * 3.183e-3;
            moonBrightness = -2.5 * Math.log10(flux_cd_m2 / (3.28e-6)) + mMoon + k * airmass;
        }

        let sunBrightness = 0;
        if (sunElevation < 0 && sunElevation >= -18) {
            sunBrightness = 22.0 - 0.58 * (sunElevation + 18);
        } else if (sunElevation >= 0) {
            sunBrightness = -10;
        }

        skyBrightnessMag = -2.5 * Math.log10(
            Math.pow(10, -0.4 * skyBrightnessMag) +
            (moonBrightness ? Math.pow(10, -0.4 * moonBrightness) : 0) +
            (sunBrightness ? Math.pow(10, -0.4 * sunBrightness) : 0)
        );

        const brightnessW = Math.pow(10, -0.4 * (skyBrightnessMag - 22.4775));
        const cloudFactor = sunElevation >= -18 && sunElevation < 0 ? 0.12 : (0.25 + (0.3125 - 0.25) * (1 - moonFraction));
        const brightnessB = brightnessW * cloudFactor;

        return { brightnessW, brightnessB };
    }

    // Funktion, die die Tabellen berechnet und die Chart-Daten vorbereitet
    function calculateMonthlyNightBrightness() {
        const lat = parseFloat(document.getElementById('nightCalcLatitude').value);
        const lon = parseFloat(document.getElementById('nightCalcLongitude').value);
        const yearMonth = document.getElementById('nightCalcMonthYear').value;
        const utcToggle = document.getElementById('nightCalcUtcToggle').checked;
        const errorDiv = document.getElementById('nightCalcError');
        const daySelector = document.getElementById('daySelectorForChart');
        const chartContainer = document.getElementById('chartContainer');

        // Reset
        errorDiv.textContent = '';
        daySelector.innerHTML = '';
        chartContainer.style.display = 'none';
        if (nightChart) {
            nightChart.destroy();
        }

        if (isNaN(lat) || isNaN(lon) || !yearMonth) {
            errorDiv.textContent = 'Bitte gib g√ºltige Werte ein!';
            return;
        }

        const [year, month] = yearMonth.split('-').map(Number);
        const daysInMonth = new Date(year, month, 0).getDate();

        const monthNames = ['Jan', 'Feb', 'M√§r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
        const monthAbbr = monthNames[month - 1];

        const localHours = [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0, 1, 2, 3, 4, 5, 6, 7];
        chartHeaders = localHours.map(hour => {
            if (utcToggle) {
                const utcHour = (hour - 2 + 24) % 24;
                return `${utcHour} Z`;
            } else {
                return `${hour}`;
            }
        });
        const tableHeaders = [monthAbbr, ...chartHeaders];

        chartValuesW = [];
        chartValuesB = [];

        for (let day = 1; day <= daysInMonth; day++) {
            const wRow = [`${day}`];
            const bRow = [`${day}`];

            for (let hour of localHours) {
                const time = new Date(Date.UTC(year, month - 1, day, hour, 0, 0)); // Berechnungen in UTC

                const sunPos = SunCalc.getPosition(time, lat, lon);
                const sunElevation = sunPos.altitude * 180 / Math.PI;

                if (sunElevation < -6) {
                    const moonPos = SunCalc.getMoonPosition(time, lat, lon);
                    const moonIllum = SunCalc.getMoonIllumination(time);
                    const { brightnessW, brightnessB } = calculateSkyBrightness(time, lat, lon, moonIllum, moonPos, sunPos);
                    wRow.push(brightnessW.toFixed(2));
                    bRow.push(brightnessB.toFixed(2));
                } else {
                    wRow.push('*****');
                    bRow.push('*****');
                }
            }
            chartValuesW.push(wRow);
            chartValuesB.push(bRow);

            // Tag zum Selector hinzuf√ºgen
            const option = document.createElement('option');
            option.value = day;
            option.textContent = day;
            daySelector.appendChild(option);
        }

        renderNightCalcTable('tableWCalc', tableHeaders, chartValuesW);
        renderNightCalcTable('tableBCalc', tableHeaders, chartValuesB);

        // Chart anzeigen und f√ºr den ersten Tag zeichnen
        chartContainer.style.display = 'block';
        updateNightBrightnessChart();
    }

    // Funktion, die die berechneten Daten in den Tabellen darstellt
    function renderNightCalcTable(tableId, headers, values) {
        const table = document.getElementById(tableId);
        if (!table) return;

        const displayMode = document.getElementById('displayMode')?.value || 'numbers';
        table.innerHTML = '';

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        values.forEach(row => {
            const tr = document.createElement('tr');
            row.forEach((val, index) => {
                const td = document.createElement('td');
                if (index === 0) {
                    td.textContent = val;
                } else if (val === '*****') {
                    td.textContent = '';
                    td.style.backgroundColor = 'white';
                } else {
                    const num = parseFloat(val);
                    if (displayMode === 'numbers') {
                        td.textContent = num.toFixed(1);
                    }
                    if (num >= 10 && num < 1000) {
                        if (displayMode === 'conclusion') td.textContent = 'B';
                        td.classList.add('big-value');
                    } else if (num > 0.7 && num < 10) {
                        if (displayMode === 'conclusion') td.textContent = '';
                        td.classList.add('mid-value');
                    } else if (num > 0.1 && num <= 0.7) {
                        if (displayMode === 'conclusion') td.textContent = 'D';
                        td.classList.add('low-value');
                    } else if (num <= 0.1) {
                        if (displayMode === 'conclusion') td.textContent = '';
                        td.classList.add('tiny-value');
                    }
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
    }

    // NEUE FUNKTION: Zeichnet und aktualisiert das Diagramm
    function updateNightBrightnessChart() {
        const daySelector = document.getElementById('daySelectorForChart');
        const selectedDay = parseInt(daySelector.value);
        const rowIndex = selectedDay - 1;

        if (rowIndex < 0 || rowIndex >= chartValuesW.length) return;

        // Daten f√ºr den ausgew√§hlten Tag extrahieren
        // .slice(1) √ºberspringt die erste Spalte (Tag)
        // '*****' wird zu null, damit Chart.js eine L√ºcke zeichnet
        const dataW = chartValuesW[rowIndex].slice(1).map(val => val === '*****' ? null : parseFloat(val));
        const dataB = chartValuesB[rowIndex].slice(1).map(val => val === '*****' ? null : parseFloat(val));

        const yearMonth = document.getElementById('nightCalcMonthYear').value;
        const [year, month] = yearMonth.split('-');
        const chartTitle = `Nachthelligkeit am ${String(selectedDay).padStart(2, '0')}.${month}.${year}`;
        const xAxisTitle = document.getElementById('nightCalcUtcToggle').checked ? 'Uhrzeit (UTC)' : 'Uhrzeit (Lokal)';

        const ctx = document.getElementById('nightBrightnessChart').getContext('2d');

        // Bestehendes Diagramm zerst√∂ren, bevor ein neues gezeichnet wird
        if (nightChart) {
            nightChart.destroy();
        }

        nightChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: chartHeaders,
                datasets: [{
                    label: 'Nachthelligkeit wolkenlos (mlx)',
                    data: dataW,
                    borderColor: 'orange',
                    backgroundColor: 'rgba(255, 165, 0, 0.2)',
                    fill: false,
                    tension: 0.1
                }, {
                    label: 'Nachthelligkeit bew√∂lkt (mlx)',
                    data: dataB,
                    borderColor: 'skyblue',
                    backgroundColor: 'rgba(135, 206, 235, 0.2)',
                    fill: false,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: chartTitle,
                        font: { size: 16 }
                    },
                    legend: {
                        position: 'top',
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: xAxisTitle
                        }
                    },
                    y: {
                        // === BEGINN DER √ÑNDERUNG ===
                        type: 'logarithmic', // Skalentyp auf logarithmisch √§ndern
                        title: {
                            display: true,
                            // Titel anpassen, um die Skala kenntlich zu machen
                            text: 'Nachthelligkeit (mlx) [logarithmisch]'
                        }
                        // Die Zeile 'beginAtZero: true' wurde entfernt.
                        // === ENDE DER √ÑNDERUNG ===
                    }
                }
            }
        });
    }

    // Event-Listener f√ºr das neue Dropdown-Men√º
    document.getElementById('daySelectorForChart').addEventListener('change', updateNightBrightnessChart);

    // Event-Listener f√ºr die Nachthelligkeiten-Eingaben
    const nightCalcLatitudeInput = document.getElementById('nightCalcLatitude');
    const nightCalcLongitudeInput = document.getElementById('nightCalcLongitude');
    const nightCalcMonthYearInput = document.getElementById('nightCalcMonthYear');
    const nightCalcUtcToggle = document.getElementById('nightCalcUtcToggle');

    if (nightCalcMonthYearInput) {
        nightCalcMonthYearInput.addEventListener('change', function () {
            calculateMonthlyNightBrightness();
            const monthYearInput = document.getElementById('monthYear');
            if (monthYearInput && monthYearInput.value !== this.value) {
                monthYearInput.value = this.value;
                if (document.getElementById('monthTable').innerHTML) {
                    calculateMonthTable();
                }
            }
        });
    }

    if (monthYearInput) {
        monthYearInput.addEventListener('change', function () {
            if (document.getElementById('monthTable').innerHTML) {
                calculateMonthTable();
            }
            const nightCalcMonthYearInput = document.getElementById('nightCalcMonthYear');
            if (nightCalcMonthYearInput && nightCalcMonthYearInput.value !== this.value) {
                nightCalcMonthYearInput.value = this.value;
                if (document.getElementById('tableWCalc').innerHTML) {
                    calculateMonthlyNightBrightness();
                }
            }
        });
    }

    nightCalcLatitudeInput.addEventListener('change', function () { syncCoordinates(this); });
    nightCalcLongitudeInput.addEventListener('change', function () { syncCoordinates(this); });

    // Datum beim Laden setzen
    window.addEventListener('load', function () {
        setCurrentDate();
        calculateDayData(); // Initiales Rendern der Tagesdaten
    });

</script>
</body>

</html>